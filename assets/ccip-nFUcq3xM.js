import{s as f,A as C,t as y,f as g,a as G,d as x,b as T,g as N,c as R,e as H,h as b,i as v,j as k,k as j,I as B,l as w,m as L,n as F,B as E,o as M,p as S,q as U,r as _,H as O,u as J}from"./index-DV8ewtTd.js";const q={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},W={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"};function Z(e){const{abi:n,data:a}=e,r=f(a,0,4);if(r==="0x")throw new C;const s=[...n||[],q,W].find(o=>o.type==="error"&&r===y(g(o)));if(!s)throw new G(r,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:s,args:"inputs"in s&&s.inputs&&s.inputs.length>0?x(s.inputs,f(a,4)):void 0,errorName:s.name}}function z(e){const{abi:n,data:a}=e,r=f(a,0,4),t=n.find(s=>s.type==="function"&&r===y(g(s)));if(!t)throw new T(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:t.name,args:"inputs"in t&&t.inputs&&t.inputs.length>0?x(t.inputs,f(a,4)):void 0}}const h="/docs/contract/encodeErrorResult";function P(e){const{abi:n,errorName:a,args:r}=e;let t=n[0];if(a){const d=N({abi:n,args:r,name:a});if(!d)throw new R(a,{docsPath:h});t=d}if(t.type!=="error")throw new R(void 0,{docsPath:h});const s=g(t),o=y(s);let c="0x";if(r&&r.length>0){if(!t.inputs)throw new H(t.name,{docsPath:h});c=b(t.inputs,r)}return v([o,c])}const m="/docs/contract/encodeFunctionResult";function K(e){const{abi:n,functionName:a,result:r}=e;let t=n[0];if(a){const o=N({abi:n,name:a});if(!o)throw new k(a,{docsPath:m});t=o}if(t.type!=="function")throw new k(void 0,{docsPath:m});if(!t.outputs)throw new j(t.name,{docsPath:m});const s=(()=>{if(t.outputs.length===0)return[];if(t.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new B(r)})();return b(t.outputs,s)}const I="x-batch-gateway:true";async function $(e){const{data:n,ccipRequest:a}=e,{args:[r]}=z({abi:w,data:n}),t=[],s=[];return await Promise.all(r.map(async(o,c)=>{try{s[c]=o.urls.includes(I)?await $({data:o.data,ccipRequest:a}):await a(o),t[c]=!1}catch(d){t[c]=!0,s[c]=Q(d)}})),K({abi:w,functionName:"query",result:[t,s]})}function Q(e){return e.name==="HttpRequestError"&&e.status?P({abi:w,errorName:"HttpError",args:[e.status,e.shortMessage]}):P({abi:[q],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}function V(e,n){if(!L(e,{strict:!1}))throw new F({address:e});if(!L(n,{strict:!1}))throw new F({address:n});return e.toLowerCase()===n.toLowerCase()}class X extends E{constructor({callbackSelector:n,cause:a,data:r,extraData:t,sender:s,urls:o}){super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],a.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(c=>`    ${M(c)}`)],`  Sender: ${s}`,`  Data: ${r}`,`  Callback selector: ${n}`,`  Extra data: ${t}`].flat(),name:"OffchainLookupError"})}}class Y extends E{constructor({result:n,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${M(a)}`,`Response: ${S(n)}`],name:"OffchainLookupResponseMalformedError"})}}class tt extends E{constructor({sender:n,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${n}`],name:"OffchainLookupSenderMismatchError"})}}const st="0x556f1830",et={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function nt(e,{blockNumber:n,blockTag:a,data:r,to:t}){const{args:s}=Z({data:r,abi:[et]}),[o,c,d,i,u]=s,{ccipRead:l}=e,A=l&&typeof l?.request=="function"?l.request:at;try{if(!V(t,o))throw new tt({sender:o,to:t});const p=c.includes(I)?await $({data:d,ccipRequest:A}):await A({data:d,sender:o,urls:c}),{data:D}=await U(e,{blockNumber:n,blockTag:a,data:_([i,b([{type:"bytes"},{type:"bytes"}],[p,u])]),to:t});return D}catch(p){throw new X({callbackSelector:i,cause:p,data:r,extraData:u,sender:o,urls:c})}}async function at({data:e,sender:n,urls:a}){let r=new Error("An unknown error occurred.");for(let t=0;t<a.length;t++){const s=a[t],o=s.includes("{data}")?"GET":"POST",c=o==="POST"?{data:e,sender:n}:void 0,d=o==="POST"?{"Content-Type":"application/json"}:{};try{const i=await fetch(s.replace("{sender}",n.toLowerCase()).replace("{data}",e),{body:JSON.stringify(c),headers:d,method:o});let u;if(i.headers.get("Content-Type")?.startsWith("application/json")?u=(await i.json()).data:u=await i.text(),!i.ok){r=new O({body:c,details:u?.error?S(u.error):i.statusText,headers:i.headers,status:i.status,url:s});continue}if(!J(u)){r=new Y({result:u,url:s});continue}return u}catch(i){r=new O({body:c,details:i.message,url:s})}}throw r}export{at as ccipRequest,nt as offchainLookup,et as offchainLookupAbiItem,st as offchainLookupSignature};
